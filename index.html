
<h3>NOTHING HERE &#128513;</h3>
<!--
    
    1.	GCD
def gcde(m, n):
    if m < n:
        (m, n) = (n, m)
    while n != 0:
        r = m % n
        m = n
        n = r
    return m


def gcd(m, n):
    t = min(m, n)
    while t > 0:
        if m % t ==0 and n % t == 0:
            return t
        t -= 1


print("Program to find GCD of two numbers")
print("1. Euclid's Algorithm ")
m = int(input("1st Number : "))
n = int(input("2nd Number : "))
print(gcde(m, n))
print("2. Consecutive integer checking Algorithm")
m = int(input("1st Number : "))
n = int(input("2nd Number : "))
print(gcd(m, n))

2.	Sieve of Eratosthenes
def soE(n):
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if prime[p] == True:
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    prime[0] = False
    prime[1] = False
    for j in range(n + 1):
        if prime[j]:
            print(j)


pi = int(input("Enter the range : "))
print("The prime numbers are : ")
soE(pi)

3.	Pattern Matching:

def search(pat, txt):
    M = len(pat)
    N = len(txt)
    for i in range(N - M + 1):
        j = 0
        while j < M:
            if txt[i + j] != pat[j]:
                break
            j += 1
            if j == M:
                print("Pattern found at index : ", i+1)


txt1 = input("Enter the text : ")
pat1 = input("Enter the pattern : ")
search(pat1, txt1)

4.	Merge sort : 

def merge(arr, low, m, r):
    n1 = m - low + 1
    n2 = r - m
    L = [0] * n1
    R = [0] * n2
    for i in range(0, n1):
        L[i] = arr[low + i]
    for j in range(0, n2):
        R[j] = arr[m + 1 + j]
    i = 0
    j = 0
    k = low
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1


def mergesort(arr, low, r):
    if low < r:
        m = low + (r - low) // 2
        mergesort(arr, low, m)
        mergesort(arr, m + 1, r)
        merge(arr, low, m, r)


arr = [11, 69, 1337, 420, 404]
n = len(arr)
print("Given array is : ")
for i in range(n):
    print(arr[i])
mergesort(arr, 0, n - 1)
print("\n\nSorted array is : ")
for i in range(n):
    print(arr[i])

5.	Quick sort:
def partition(Array, low, up):
    i = low + 1
    j = up
    pivot = Array[low]
    while i <= j:
        while Array[i] <= pivot and i < up:
            i += 1
        while Array[j] > pivot :
            j -= 1
        if i < j:
            Array[i], Array[j] = Array[j], Array[i]
            i += 1
            j -= 1
        else:
            i += 1
    Array[low] = Array[j]
    Array[j] = pivot
    return j


def quick(Array, low, up):
    if low >= up:
        return
    piv_loc = partition(Array, low, up)
    quick(Array, low, piv_loc - 1)
    quick(Array, piv_loc + 1, up)


n = int(input("Number of elements : "))
Array = []
print("Enter the elements : ")
for i in range(n):
    Array.append(int(input()))
print(Array)
low = 0
up = len(Array) - 1
print (up)
quick(Array, low, up)
for i in Array:
    print(i)


6. Prims Algorithm :
INF = 999999999
V = 5
G = [[0, 9, 75, 0, 0], [9, 0, 95, 19, 42], [75, 95, 0, 51, 66], [0, 19, 51, 0, 31], [0, 42, 66, 31, 0]]
print(G[1][0])
selected = [0, 0, 0, 0, 0]
num_edge = 0
selected[0] = True
print("Edge : Weight\n")
while num_edge < V - 1:
    minimum = INF
    x = 0
    y = 0
    for i in range(V):
        if selected[i]:
            for j in range(V):
                if not selected[j] and G[i][j]:
                    if minimum > G[i][j]:
                        minimum = G[i][j]
                        x = i
                        y = j
    print(str(x) + ", " + str(y) + " : " + str(G[x][y]))
    selected[y] = True
    num_edge += 1



