<h1>HI</h1>
<!--
*****************************************1.FIND GCD OF NUMBER

def gcd1(m,n):
  l1=[]
  mini=min(m,n)
  for i in range (1,mini+1):
    if(m%i==0) and (n%i==0):
      l1.append(i)
  return max(l1)

print("Enter the two numbers")
a= int(input())
b= int(input())
print(gcd1(a,b))

*****************************************2.Sieve of Eratosthenes to 
generate Prime Numbers Between Given Range

def prime(n):
    nonprime=set()
    prime=[]
    for i in range(2,n+1):
        if i not in nonprime:
            prime.append(i)
        for j in range(i*i,n+1,i):
            nonprime.add(j)
    print("prime numbers: ",prime)
    print("composite numbers are: ",nonprime)
    
n=int(input("enter the value of n: " ))
prime(n)

********************************************3.string matching using Brute 
force

def smatch(s1,sub):
  l1= len(s1)
  l2= len(sub)
  for i in range(0,l1-l2+1):
    j=0
    while(j<l2):
      if (s1[i+j]!=sub[j]):
        break
      j=j+1
    if(j==l2):
      return print("Pattern found at",i)
      break
  return -1

s1= input("Enter the main string: ")
sub= input("Enter the substring: ")
smatch(s1,sub)

************************************4.  Merge Sort 

#      MergeSort
def mergeSort(a, start, end):
    if start < end:
 
        mid = (start+end)//2

        mergeSort(a, start, mid)
        mergeSort(a, mid+1, end)
        merge(a, start, mid, end)

def merge(a, start, mid, end):
    
    L = a[start:mid+1]
    R = a[mid+1:end+1]
    
    n = len(L)
    m = len(R)
 
    i = 0     
    j = 0     
    k = start     
 
    # COMPARE AND COPY 
    
    while i < n and j < m:
        if L[i] <= R[j]:
            a[k] = L[i]
            i += 1
        else:
            a[k] = R[j]
            j += 1
        k += 1
 
    # Copy the remaining elements of L[], if there are any
    while i < n:
        a[k] = L[i]
        i += 1
        k += 1
 
    # Copy the remaining elements of R[], if there are any
    while j < m:
        a[k] = R[j]
        j += 1
        k += 1
 
arr = []
N = int(input("Enter the number of elements to be sorted : "))
print("Enter the elements: \n")

for i in range (N):
    n = int(input())
    arr.append(n)

print("Given array is",arr) 
mergeSort(arr, 0, N-1)
print("\n\nSorted array is",arr)

************************************** 5. Quick Sort
def partition(arr, start, end):
	i = (start-1)
	pivot = arr[end]

	for j in range(start, end):
		if arr[j] <= pivot:
			i = i+1
			arr[i], arr[j] = arr[j], arr[i]

	arr[i+1], arr[end] = arr[end], arr[i+1]
	return (i+1)
def quickSort(arr, start, end):
	if len(arr) == 1:
		return arr
	if start < end:
		pi = partition(arr, start, end)
		quickSort(arr, start, pi-1)
		quickSort(arr, pi+1, end)
arr = []
N = int(input("Enter the number of elements to be sorted : "))
print("Enter the elements: \n")

for i in range (N):
    n = int(input())
    arr.append(n)

print("Given array is",arr) 
size = len(arr)
quickSort(arr,0,size-1)
print("\n\nSorted array is",arr)

************************************* 6.Prim’s Algorithm 
INF = 9999999
V = 5

#Adjacency matrix method
G = [[0, 19, 5, 0, 0],
     [19, 0, 5, 9, 2],
     [5, 5, 0, 1, 6],
     [0, 9, 1, 0, 1],
     [0, 2, 6, 1, 0]]

visited = [0, 0, 0, 0, 0]
visited [0] = True
E = 0
cost = 0

print("\nEdge : Weight\n")
while (E < V - 1):
    
    minimum = INF
    a = 0
    b = 0
    for i in range(V):
        if visited[i]:
            for j in range(V):
                if ((not visited[j]) and G[i][j]):  
                    # not in selected and there is an edge
                    if minimum > G[i][j]:
                        minimum = G[i][j]
                        a = i
                        b = j
    print(str(a) + "-" + str(b) + ":" + str(G[a][b])) 
    cost = cost + G[a][b]
    visited[b] = True
    E += 1
    
print("Cost = " + str(cost))

************************************** 7.Kruskal’s Algorithm
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []

    def add_edge(self, u, v, w):
        self.graph.append([u, v, w])

    # Search function

    def find(self, parent, i):
        if parent[i] == i:
            return i
        return self.find(parent, parent[i])

    def apply_union(self, parent, rank, x, y):
        xroot = self.find(parent, x)
        yroot = self.find(parent, y)
        if rank[xroot] < rank[yroot]:
            parent[xroot] = yroot
        elif rank[xroot] > rank[yroot]:
            parent[yroot] = xroot
        else:
            parent[yroot] = xroot
            rank[xroot] += 1

    #  Applying Kruskal algorithm
    def kruskal_algo(self):
        result = []
        i, e = 0, 0
        self.graph = sorted(self.graph, key=lambda item: item[2])
        parent = []
        rank = []
        for node in range(self.V):
            parent.append(node)
            rank.append(0)
        while e < self.V - 1:
            u, v, w = self.graph[i]
            i = i + 1
            x = self.find(parent, u)
            y = self.find(parent, v)
            if x != y:
                e = e + 1
                result.append([u, v, w])
                self.apply_union(parent, rank, x, y)
        for u, v, weight in result:
            print("%d - %d: %d" % (u, v, weight))


g = Graph(6)
g.add_edge(0, 1, 4)
g.add_edge(0, 2, 4)
g.add_edge(1, 2, 2)
g.add_edge(1, 0, 4)
g.add_edge(2, 0, 4)
g.add_edge(2, 1, 2)
g.add_edge(2, 3, 3)
g.add_edge(2, 5, 2)
g.add_edge(2, 4, 4)
g.add_edge(3, 2, 3)
g.add_edge(3, 4, 3)
g.add_edge(4, 2, 4)
g.add_edge(4, 3, 3)
g.add_edge(5, 2, 2)
g.add_edge(5, 4, 3)
g.kruskal_algo()

*****************************8. Djikstra’s algorithm
class Graph(): 
    def __init__(self, nodes):
        
        self.d = [0 for i in range(nodes)]
        self.visited = [0 for i in range(nodes)]
        self.V = nodes
        self.INF = 1000000
        self.graph = [[0 for column in range(nodes)]  
                    for row in range(nodes)]
   
    def dijkstra(self, srcNode):
        for i in range(self.V):
         
          self.d[i] = self.INF
          self.visited[i] = False
        self.d[srcNode] = 0
        for i in range(self.V): 
  
            u = self.minDistance(self.d, self.visited) 
  
            self.visited[u] = True
  
            for v in range(self.V): 
                if self.graph[u][v] > 0 and self.visited[v] == False and self.d[v] > self.d[u] + self.graph[u][v]: 
                        self.d[v] = self.d[u] + self.graph[u][v] 
  
        self.display(self.d)

    
    def minDistance(self, d, visited): 
  
        min = self.INF
  
        for v in range(self.V): 
            if d[v] < min and visited[v] == False: 
                min = d[v] 
                min_index = v 
  
        return min_index

    def display(self, d): 
        print ("Node \tDistance from 0")
        for i in range(self.V): 
            print (i, "\t", d[i])
#Display our table
Graph1 = Graph(4) 
INF=99999
Graph1.graph = [[0, INF, 3, INF], 
        [2, 0, INF, INF], 
        [INF, 7, 0, 1], 
        [6, INF, INF, 0]] 
  
Graph1.dijkstra(0)
**************************** 9.Binomial Coefficient
def bicoeff(n,r):
    # c = []
    # for i in range (n+1):
    #     a = []
    # for j in range (r+1):
    #     a.append(0)
    # c.append(a)
    c=[[0 for j in range (r+1)] for i in range (n+1)]
    for i in range(n+1):
        for j in range (r+1):
            if (j<=i):
                if (j==0 or j==i):
                    c[i][j] = 1
                else:
                    c[i][j] = c[i-1][j-1]+c[i-1][j]
    print (n,"C",r, " = ", c[n][r])

n = int(input("n = "))
r = int(input("r = "))
bicoeff(n,r)
**********************************10.  Floyds algorithms
INF = 99999

def floyd(G,v):
    d = G
    for k in range (v):
        for i in range (v):
            for j in range(v):
                d[i][j] = min(d[i][j],d[i][k]+d[k][j])
    display(d,v)

def display(d,v):
    print ("Distance Matrix")
    for i in range(v):
        for j in range(v):
                print(d[i][j],"\t",end=" ")
        print()


v = int (input("Enter number of Vertices:\n"))
G = []

for i in range (v):
    a = []
    for j in range (v):
        r = int (input("Enter distance:"))
        a.append(r)
    G.append(a)
floyd(G,v)

********************************11.  Warshall’s algorithm
INF = 99999

def warshall(G,v):
    r = G
    for k in range (v):
        for i in range (v):
            for j in range(v):
                r[i][j] = r[i][j] or (r[i][k] and r[k][j])
    display(r,v)

def display(d,v):
    print ("Reachability Matrix")
    for i in range(v):
        for j in range(v):
                print(d[i][j],"\t",end=" ")
        print()

v = int (input("Enter number of Vertices:\n"))
G = []

for i in range (v):
    a = []
    for j in range (v):
        r = int (input("Enter distance:"))
        a.append(r)
    G.append(a)

warshall(G,v)

*****************************12.  Breadth First search 
graph={
    'A': ['B','C'],
    'B': ['A','D','E'],
    'C': ['A','E'],
    'D': ['B','E','F'],
    'E': ['B','C','D','F'],
    'F': ['D','E'],
    }
print(graph)
print("output")
visited=[]
queue=[]

def bfs(visited,graph,node):
    visited.append(node)
    queue.append(node)
    while queue:
        s= queue.pop(0)
        print(s, end=" ")
        for neighbour in graph[s]:
            if neighbour not in visited:
                visited.append(neighbour) 
                queue.append(neighbour)
bfs(visited,graph,'A')

********************* 13.Depth First search 
def dfs(start):
    print(start,end='')
    visited[start]=1
    for i in range(v):
        if (G[start][i] and not visited[i]):
            dfs(i)

v = int (input("Enter number of Vertices:\n"))

G = []

for i in range (v):
    a = []
    for j in range (v):
        r = int (input("Enter the entries rowwise:"))
        a.append(r)
    G.append(a)
visited = [0 for i in range (v)]

print("\nThe Adjajency Matrix Is - \n")

for i in range(v):
    for j in range(v):
        print(G[i][j],"\t",end=" ")
    print()
    
dfs(0)

*****************************14.  Topological sorting
from collections import defaultdict

class Graph:
	def __init__(self, vertices):
		self.graph = defaultdict(list)
		self.V = vertices 

	def addEdge(self, u, v):
		self.graph[u].append(v)

	def topologicalSortUtil(self, v, visited, stack):

		visited[v] = True

		for i in self.graph[v]:
			if visited[i] == False:
				self.topologicalSortUtil(i, visited, stack)
		stack.append(v)
  
	def topologicalSort(self):

		visited = [False]*self.V
		stack = []

		for i in range(self.V):
			if visited[i] == False:
				self.topologicalSortUtil(i, visited, stack)

		print(stack[::-1])

g = Graph(6)
g.addEdge(5, 2)
g.addEdge(5, 0)
g.addEdge(4, 0)
g.addEdge(4, 1)
g.addEdge(2, 3)
g.addEdge(3, 1)

print ("Following is a Topological Sort of the given graph")

g.topologicalSort()

***********************15. t Subset Sum problem using Backtracking
def allset(a,n,v,total):
    if total == 0:
        for value in v :
            print(value,end=" ")
        print()
        return
    if n == 0:
        return
    allset(a,n-1,v,total)
    v1 = []+v
    v1.append(a[n-1])
    allset(a,n-1,v1,total-a[n-1])
    
def printarray(a,n,total):
    v= []
    print("The solutions are : ")
    allset(a,n,v,total)
    
a = []
n = int(input("Enter the length of set : "))
total = int(input("Enter the sum value : "))
print("Enter the elements of the set : ")
for i in range(n):
    x = int(input())
    a.append(x)
printarray(a,n,total)
***********************************16.  N Queens problem using Backtracking
def isSafe(mat, r, c):
	for i in range(r):
		if mat[i][c] == 'Q':
			return False
	(i, j) = (r, c)
	while i >= 0 and j >= 0:
		if mat[i][j] == 'Q':
			return False
		i = i - 1
		j = j - 1
	(i, j) = (r, c)
	while i >= 0 and j < len(mat):
		if mat[i][j] == 'Q':
			return False
		i = i - 1
		j = j + 1

	return True


def printSolution(mat):
	for r in mat:
		print(str(r).replace(',', '').replace('\'', ''))
	print()


def nQueen(mat, r):
	if r == len(mat):
		printSolution(mat)
		return
	for i in range(len(mat)):
		if isSafe(mat, r, i):
			mat[r][i] = 'Q'
			nQueen(mat, r + 1)
			mat[r][i] = ('–')

N=int(input("Enter the number of Queens: "))
mat = [['–' for x in range(N)] for y in range(N)]
nQueen(mat, 0)



